# -*- coding: utf-8 -*-
"""homework4_1225653286.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1orbTdDly6wsZwxKbV38fyUjU6EG4OF9q
"""

!sudo apt-get update -y
!sudo apt-get install python3.10

import numpy as np
import cv2
import glob
from google.colab.patches import cv2_imshow
!pip install gdown
import matplotlib.pyplot as plt
import gdown
import glob
from google.colab.patches import cv2_imshow

# get the required folder from drive to collab space
url = 'https://drive.google.com/drive/folders/1O9JHexWsMWOXqX54UWj5QikZGno-FZ2c?usp=sharing'


gdown.download_folder(url,quiet=True, use_cookies=False)

!mkdir -p /content/sample_data/images
# !mv /content/images/* /content/sample_data/images/
# !mkdir images

# termination criteria
criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 30, 0.001)

# prepare object points, like (0,0,0), (1,0,0), (2,0,0) ....,(6,5,0)
objp = np.zeros((6*8,3), np.float32)
objp[:,:2] = np.mgrid[0:8,0:6].T.reshape(-1,2)

# Arrays to store object points and image points from all the left_images.
objpoints = [] # 3d point in real world space
imgpoints = [] # 2d points in image plane.

# TODO Part A (1): load the list of images in images using glob or any other function.
path = "/content/images/*left*.*"
images = []
for img in glob.glob(path):
  print(img)
  images.append(img)
pathkau = "/content/images/*kaus*.*"
images_kaus = []
for img in glob.glob(pathkau):
  print(img)
  images_kaus.append(img)

# # resize  images
# import os
# directory = "/content/images"
# path = os.path.join(directory, '*left*.*')

# # Loop through all the images in the directory
# for img_path in glob.glob(path):
#     img = cv2.imread(img_path)
#     new_width = int(img.shape[1])
#     new_height = int(img.shape[0])
#     img_resized = cv2.resize(img, (new_width, new_height))
#     # Get the original file name and extension
#     filename, ext = os.path.splitext(os.path.basename(img_path))

#     # Create a new file name with "_resized" added before the extension
#     new_filename = f"{filename}{ext}"
#     if os.path.exists(os.path.join(directory, new_filename)):
#         os.remove(os.path.join(directory, new_filename))

#     # Save the resized image to the same directory as the original image
#     cv2.imwrite(os.path.join(directory, new_filename), img_resized)

#     # cv2.imwrite(f'/content/images/img_resized.jpg",img_resized)
#     # images.append(new_filename)


# print(images)

for fname in images:
    print(fname)
    # read image
    # TODO Part A (1): read the image from "fname" using cv2 imread
    img = cv2.imread(fname)
    img1 = cv2.imread(fname)
    # print(img.shape)

    # cv2_imshow(img)
    # TODO Part A (2): convert img to gray scale using cvtColor using cv2.COLOR_BGR2GRAY parameter
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    # print(gray)

    # Find the chess board corners
    # TODO Part A (3): find chess board corners using cv2 findChessboardCorners function, with "gray", grid size
    ret, corners = cv2.findChessboardCorners(gray, (8, 6), None)
    # ret, corners =cv2.findChessboardCornersSB(gray, (8, 6))

    if ret == False:
      new_width = int(500)
      new_height = int(500)
      img = cv2.resize(img, (new_width, new_height))
      gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
      ret, corners = cv2.findChessboardCorners(gray, (8, 6), None)
    print(ret)
    # If found, add object points, image points (after refining them)
    if ret == True:
        objpoints.append(objp)

        corners2 = cv2.cornerSubPix(gray,corners,(11,11),(-1,-1),criteria)
        imgpoints.append(corners2)

        # Draw and display the corners
        # TODO Part A (6): find chess board corners using cv2 drawChessboardCorners function, with "img", grid size, corners2, and ret as parameters
        img = cv2.drawChessboardCorners(img, (7, 6), corners2, ret)
        img = cv2.resize (img, (500, 500))


        height = min(img1.shape[0], img.shape[0])
        img1 = cv2.resize(img1, (int(img1.shape[1] * height / img1.shape[0]), height))
        img = cv2.resize(img, (int(img.shape[1] * height / img.shape[0]), height))


        concatenated_img = cv2.hconcat([img1, img])

        # Display the concatenated image
        cv2_imshow(concatenated_img)

        # cv2_imshow(img)
        # TODO Part A (4): display the image using cv2_imshow

# TODO Part A (5): Compute camera matrix using cv2 calibrateCamera with objpoints, imgpoints, gray.shape[::-1] as parameters
ret, mtx, dist, rvecs, tvecs = cv2.calibrateCamera(objpoints, imgpoints, gray.shape[::-1], None, None)

img = cv2.imread(images[9])
h,  w = img.shape[:2]

# the new camera matrix is being computed to remove the distortion
newcameramtx, roi=cv2.getOptimalNewCameraMatrix(mtx,dist,(w,h),1,(w,h))

# undistort
dst = cv2.undistort(img, mtx, dist, None, newcameramtx)

# crop the image
x,y,w,h = roi
dst = dst[y:y+h, x:x+w]
cv2.imwrite('calibresult.png',dst)

def draw(img, corners, imgpts):
    corner = tuple(corners[0].ravel())
    kk=tuple(imgpts[0].ravel().astype(int))
    print(tuple(imgpts[0].ravel().astype(int)))
    img = cv2.line(img, (int(corner[0]),int(corner[1])), tuple(imgpts[0].ravel().astype(int)), (255,0,0), 5)
    img = cv2.line(img, (int(corner[0]),int(corner[1])), tuple(imgpts[1].ravel().astype(int)), (0,255,0), 5)
    img = cv2.line(img, (int(corner[0]),int(corner[1])), tuple(imgpts[2].ravel().astype(int)), (0,0,255), 5)
    return img

criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 30, 0.001)
objp = np.zeros((6*8,3), np.float32)
objp[:,:2] = np.mgrid[0:8,0:6].T.reshape(-1,2)
axis = np.float32([[3,0,0], [0,3,0], [0,0,-3]]).reshape(-1,3)
print ('done')

for fname in images:
    print(fname)
    # read image
    # TODO Part A (1): read the image from "fname" using cv2 imread
    img = cv2.imread(fname)
    img1 = cv2.imread(fname)
    # TODO Part A (2): convert img to gray scale using cvtColor using cv2.COLOR_BGR2GRAY parameter
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

    # Find the chess board corners
    # TODO Part A (3): find chess board corners using cv2 findChessboardCorners function, with "gray", grid size
    ret, corners = cv2.findChessboardCorners(gray, (8, 6), None)

    if ret == False:
      new_width = int(500)
      new_height = int(500)
      img = cv2.resize(img, (new_width, new_height))
      gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
      ret, corners = cv2.findChessboardCorners(gray, (8, 6), None)
    # print(ret)

    if ret == True:
        corners2 = cv2.cornerSubPix(gray,corners,(11,11),(-1,-1),criteria)

        # Find the rotation and translation vectors.
        # TODO Part A (7): Find rotation and translation matrix by calling cv2.solvePnP using objp, corners2, mtx and dist as parameters
        ret,rvecs, tvecs = cv2.solvePnP(objp, corners2, mtx, dist)

        # TODO Part B: Print the distance from the camera using np linalg norm function with tvecs as input and mention the unit of measurement in pdf
        print(np.linalg.norm(tvecs, ord=None, axis=None, keepdims=False))
        # project 3D points to image plane
        imgpts, jac = cv2.projectPoints(axis, rvecs, tvecs, mtx, dist)
        img = draw(img,corners2,imgpts)
        img = cv2.resize (img, (500, 500))

        height = min(img1.shape[0], img.shape[0])
        img1 = cv2.resize(img1, (int(img1.shape[1] * height / img1.shape[0]), height))
        img = cv2.resize(img, (int(img.shape[1] * height / img.shape[0]), height))


        concatenated_img = cv2.hconcat([img1, img])

        # Display the concatenated image
        cv2_imshow(concatenated_img)


        # cv2_imshow(img)
        # TODO Part A (4): display the image using cv2_imshow

# Part C
# termination criteria
criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 30, 0.001)

# prepare object points, like (0,0,0), (1,0,0), (2,0,0) ....,(6,5,0)
objp = np.zeros((4*8,3), np.float32)
objp[:,:2] = np.mgrid[0:8,0:4].T.reshape(-1,2)

# Arrays to store object points and image points from all the left_images.
objpoints = [] # 3d point in real world space
imgpoints = [] # 2d points in image plane.

# resize my images
import os
directory = "/content/images"
path = os.path.join(directory, '*kaus*.*')

# Loop through all the images in the directory
for img_path in glob.glob(path):
    img = cv2.imread(img_path)
    new_width = int(640)
    new_height = int(480)
    img_resized = cv2.resize(img, (new_width, new_height))
    # Get the original file name and extension
    filename, ext = os.path.splitext(os.path.basename(img_path))

    # Create a new file name with "_resized" added before the extension
    new_filename = f"{filename}{ext}"
    if os.path.exists(os.path.join(directory, new_filename)):
        os.remove(os.path.join(directory, new_filename))

    # Save the resized image to the same directory as the original image
    cv2.imwrite(os.path.join(directory, new_filename), img_resized)

    # cv2.imwrite(f'/content/images/img_resized.jpg",img_resized)
    # images.append(new_filename)


# print(images_kaus)

import matplotlib.pyplot as plt
for fname in images_kaus:
    print(fname)
    # read image
    # TODO Part A (1): read the image from "fname" using cv2 imread
    img = cv2.imread(fname)
    img1 = cv2.imread(fname)
    # print(img.shape)

    # cv2_imshow(img)
    # TODO Part A (2): convert img to gray scale using cvtColor using cv2.COLOR_BGR2GRAY parameter
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    # print(gray)

    # Find the chess board corners
    # TODO Part A (3): find chess board corners using cv2 findChessboardCorners function, with "gray", grid size
    ret, corners = cv2.findChessboardCornersSB(gray, (8, 4), None)
    # ret, corners =cv2.findChessboardCornersSB(gray, (8, 6))
    if ret == False:
      new_width = int(450)
      new_height = int(450)
      img = cv2.resize(img, (new_width, new_height))
      gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
      ret, corners = cv2.findChessboardCornersSB(gray, (8, 4),None)
    print(ret)
    # If found, add object points, image points (after refining them)
    if ret == True:
        objpoints.append(objp)

        corners2 = cv2.cornerSubPix(gray,corners,(11,11),(-1,-1),criteria)
        imgpoints.append(corners2)

        # Draw and display the corners
        # TODO Part A (6): find chess board corners using cv2 drawChessboardCorners function, with "img", grid size, corners2, and ret as parameters
        img = cv2.drawChessboardCorners(img, (8, 4), corners2, ret)
        img = cv2.resize (img, (500, 500))

        height = min(img1.shape[0], img.shape[0])
        img1 = cv2.resize(img1, (int(img1.shape[1] * height / img1.shape[0]), height))
        img = cv2.resize(img, (int(img.shape[1] * height / img.shape[0]), height))


        concatenated_img = cv2.hconcat([img1, img])

        # Display the concatenated image
        cv2_imshow(concatenated_img)
        # cv2_imshow()


        # cv2_imshow(img)
        # TODO Part A (4): display the image using cv2_imshow

ret, mtx, dist, rvecs, tvecs = cv2.calibrateCamera(objpoints, imgpoints, gray.shape[::-1], None, None)
img = cv2.imread(images[1])
h,  w = img.shape[:2]

# the new camera matrix is being computed to remove the distortion
newcameramtx, roi=cv2.getOptimalNewCameraMatrix(mtx,dist,(w,h),1,(w,h))

# undistort
dst = cv2.undistort(img, mtx, dist, None, newcameramtx)

# crop the image
x,y,w,h = roi
dst = dst[y:y+h, x:x+w]
cv2.imwrite('calibresult1.png',dst)

def draw(img, corners, imgpts):
    corner = tuple(corners[0].ravel())
    kk=tuple(imgpts[0].ravel().astype(int))
    print(tuple(imgpts[0].ravel().astype(int)))
    img = cv2.line(img, (int(corner[0]),int(corner[1])), tuple(imgpts[0].ravel().astype(int)), (255,0,0), 5)
    img = cv2.line(img, (int(corner[0]),int(corner[1])), tuple(imgpts[1].ravel().astype(int)), (0,255,0), 5)
    img = cv2.line(img, (int(corner[0]),int(corner[1])), tuple(imgpts[2].ravel().astype(int)), (0,0,255), 5)
    return img

criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 30, 0.001)
objp = np.zeros((4*8,3), np.float32)
objp[:,:2] = np.mgrid[0:8,0:4].T.reshape(-1,2)
axis = np.float32([[3,0,0], [0,3,0], [0,0,-3]]).reshape(-1,3)
print ('done')

# resize my images
import os
directory = "/content/images"
path = os.path.join(directory, '*kaus*.*')

# Loop through all the images in the directory
for img_path in glob.glob(path):
    img = cv2.imread(img_path)
    new_width = int(640)
    new_height = int(480)
    img_resized = cv2.resize(img, (new_width, new_height))
    # Get the original file name and extension
    filename, ext = os.path.splitext(os.path.basename(img_path))

    # Create a new file name with "_resized" added before the extension
    new_filename = f"{filename}{ext}"
    if os.path.exists(os.path.join(directory, new_filename)):
        os.remove(os.path.join(directory, new_filename))

    # Save the resized image to the same directory as the original image
    cv2.imwrite(os.path.join(directory, new_filename), img_resized)

for fname in images_kaus:
    print(fname)
    # read image
    # TODO Part A (1): read the image from "fname" using cv2 imread
    img = cv2.imread(fname)
    img1 = cv2.imread(fname)
    # TODO Part A (2): convert img to gray scale using cvtColor using cv2.COLOR_BGR2GRAY parameter
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

    # Find the chess board corners
    # TODO Part A (3): find chess board corners using cv2 findChessboardCorners function, with "gray", grid size
    ret, corners = cv2.findChessboardCorners(gray, (8, 4), None)

    if ret == False:
      new_width = int(500)
      new_height = int(500)
      img = cv2.resize(img, (new_width, new_height))
      gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
      ret, corners = cv2.findChessboardCorners(gray, (8, 4), None)
    print(ret)

    if ret == True:
        corners2 = cv2.cornerSubPix(gray,corners,(11,11),(-1,-1),criteria)

        # Find the rotation and translation vectors.
        # TODO Part A (7): Find rotation and translation matrix by calling cv2.solvePnP using objp, corners2, mtx and dist as parameters
        ret,rvecs, tvecs = cv2.solvePnP(objp, corners2, mtx, dist)

        # TODO Part B: Print the distance from the camera using np linalg norm function with tvecs as input and mention the unit of measurement in pdf
        print(np.linalg.norm(tvecs, ord=None, axis=None, keepdims=False))
        # project 3D points to image plane
        imgpts, jac = cv2.projectPoints(axis, rvecs, tvecs, mtx, dist)
        img = draw(img,corners2,imgpts)
        img = cv2.resize (img, (500, 500))

        height = min(img1.shape[0], img.shape[0])
        img1 = cv2.resize(img1, (int(img1.shape[1] * height / img1.shape[0]), height))
        img = cv2.resize(img, (int(img.shape[1] * height / img.shape[0]), height))


        concatenated_img = cv2.hconcat([img1, img])

        # Display the concatenated image
        cv2_imshow(concatenated_img)
        # cv2_imshow(img)
        # TODO Part A (4): display the image using cv2_imshow
